// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.20.0
// source: queries.sql

package db

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
)

const createComment = `-- name: CreateComment :one
INSERT INTO threads (
    root_id,
    parent_id,
    author_id,
    content
) VALUES ($1, $2, $3, $4) 
RETURNING id, root_id, parent_id, author_id, created_at, title, content
`

type CreateCommentParams struct {
	RootID   uuid.UUID
	ParentID uuid.NullUUID
	AuthorID int32
	Content  string
}

func (q *Queries) CreateComment(ctx context.Context, arg CreateCommentParams) (Thread, error) {
	row := q.db.QueryRowContext(ctx, createComment,
		arg.RootID,
		arg.ParentID,
		arg.AuthorID,
		arg.Content,
	)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.RootID,
		&i.ParentID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.Title,
		&i.Content,
	)
	return i, err
}

const createPost = `-- name: CreatePost :one
INSERT INTO threads (
    id,
    root_id,
    author_id,
    title,
    content
) VALUES ($1, $2, $3, $4, $5) 
RETURNING id, root_id, parent_id, author_id, created_at, title, content
`

type CreatePostParams struct {
	ID       uuid.UUID
	RootID   uuid.UUID
	AuthorID int32
	Title    sql.NullString
	Content  string
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (Thread, error) {
	row := q.db.QueryRowContext(ctx, createPost,
		arg.ID,
		arg.RootID,
		arg.AuthorID,
		arg.Title,
		arg.Content,
	)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.RootID,
		&i.ParentID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.Title,
		&i.Content,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    username,
    password
) VALUES ($1, $2)
RETURNING id, username, password, created_at
`

type CreateUserParams struct {
	Username string
	Password []byte
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser, arg.Username, arg.Password)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const createVote = `-- name: CreateVote :one
INSERT INTO votes (
    voter_id,
    thread_id,
    upvote
) VALUES ($1, $2, $3)
ON CONFLICT ON CONSTRAINT votes_voter_id_thread_id_key DO UPDATE SET upvote = $3 WHERE votes.voter_id = $1 AND votes.thread_id = $2
RETURNING id, voter_id, thread_id, upvote, created_at
`

type CreateVoteParams struct {
	VoterID  int32
	ThreadID uuid.UUID
	Upvote   bool
}

func (q *Queries) CreateVote(ctx context.Context, arg CreateVoteParams) (Vote, error) {
	row := q.db.QueryRowContext(ctx, createVote, arg.VoterID, arg.ThreadID, arg.Upvote)
	var i Vote
	err := row.Scan(
		&i.ID,
		&i.VoterID,
		&i.ThreadID,
		&i.Upvote,
		&i.CreatedAt,
	)
	return i, err
}

const deleteVote = `-- name: DeleteVote :exec
DELETE FROM votes WHERE voter_id=$1 AND thread_id=$2
`

type DeleteVoteParams struct {
	VoterID  int32
	ThreadID uuid.UUID
}

func (q *Queries) DeleteVote(ctx context.Context, arg DeleteVoteParams) error {
	_, err := q.db.ExecContext(ctx, deleteVote, arg.VoterID, arg.ThreadID)
	return err
}

const getThread = `-- name: GetThread :one
SELECT id, root_id, parent_id, author_id, created_at, title, content FROM threads WHERE id=$1 LIMIT 1
`

func (q *Queries) GetThread(ctx context.Context, id uuid.UUID) (Thread, error) {
	row := q.db.QueryRowContext(ctx, getThread, id)
	var i Thread
	err := row.Scan(
		&i.ID,
		&i.RootID,
		&i.ParentID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.Title,
		&i.Content,
	)
	return i, err
}

const getThreadExtended = `-- name: GetThreadExtended :one
WITH selected_threads AS (
	SELECT id, root_id, parent_id, author_id, created_at, title, content FROM threads thread 
    WHERE thread.id = $2
    LIMIT 1
),
reply_counts AS (
	SELECT parent_id as thread_id, COUNT(*) as reply_count
	FROM threads thread
	WHERE thread.parent_id IN (SELECT id FROM selected_threads)
	GROUP BY thread.parent_id
),
vote_counts AS (
	SELECT v.thread_id as thread_id,
	COUNT(CASE WHEN upvote THEN 1 ELSE NULL END) as upvote_count, 
	COUNT(CASE WHEN NOT upvote THEN 1 ELSE NULL END) as downvote_count 
	FROM votes v
	WHERE v.thread_id IN (SELECT id FROM selected_threads)
	GROUP BY v.thread_id
)
SELECT 
    -- thread info
	st.id, st.root_id, st.parent_id, st.author_id, st.created_at, st.title, st.content,
    -- extended info
	u.username,
	coalesce(rc.reply_count, 0) as reply_count,
	coalesce(vc.upvote_count, 0) as upvote_count,
	coalesce(vc.downvote_count, 0) as downvote_count,
	EXISTS (SELECT 1 FROM votes v1 WHERE v1.thread_id = st.id AND v1.voter_id = $1 AND v1.upvote = TRUE) as has_upvoted,
    EXISTS (SELECT 1 FROM votes v2 WHERE v2.thread_id = st.id AND v2.voter_id = $1 AND v2.upvote = FALSE) as has_downvoted
FROM selected_threads st
LEFT JOIN reply_counts rc ON st.id = rc.thread_id
LEFT JOIN vote_counts vc ON st.id = vc.thread_id
INNER JOIN users u ON st.author_id = u.id
`

type GetThreadExtendedParams struct {
	ReaderID sql.NullInt32
	ID       uuid.UUID
}

type GetThreadExtendedRow struct {
	ID            uuid.UUID
	RootID        uuid.UUID
	ParentID      uuid.NullUUID
	AuthorID      int32
	CreatedAt     time.Time
	Title         sql.NullString
	Content       string
	Username      string
	ReplyCount    int64
	UpvoteCount   int64
	DownvoteCount int64
	HasUpvoted    bool
	HasDownvoted  bool
}

func (q *Queries) GetThreadExtended(ctx context.Context, arg GetThreadExtendedParams) (GetThreadExtendedRow, error) {
	row := q.db.QueryRowContext(ctx, getThreadExtended, arg.ReaderID, arg.ID)
	var i GetThreadExtendedRow
	err := row.Scan(
		&i.ID,
		&i.RootID,
		&i.ParentID,
		&i.AuthorID,
		&i.CreatedAt,
		&i.Title,
		&i.Content,
		&i.Username,
		&i.ReplyCount,
		&i.UpvoteCount,
		&i.DownvoteCount,
		&i.HasUpvoted,
		&i.HasDownvoted,
	)
	return i, err
}

const getThreads = `-- name: GetThreads :many
WITH selected_threads AS (
	SELECT id, root_id, parent_id, author_id, created_at, title, content FROM threads thread 
    WHERE thread.author_id = coalesce($2, thread.author_id) -- filter threads from one author
    AND thread.root_id = coalesce($3, thread.root_id) -- filter threads from one root conversation
    AND (NOT $4::bool OR thread.parent_id IS NULL) -- if root threads only then thread.parent_id must be null
    AND (NOT $5::bool OR thread.parent_id IS NOT NULL) -- if child threads only then thread.parent_id must be not null
	ORDER BY thread.created_at DESC
),
reply_counts AS (
	SELECT parent_id as thread_id, COUNT(*) as reply_count
	FROM threads thread
	WHERE thread.parent_id IN (SELECT id FROM selected_threads)
	GROUP BY thread.parent_id
),
vote_counts AS (
	SELECT v.thread_id as thread_id,
	COUNT(CASE WHEN upvote THEN 1 ELSE NULL END) as upvote_count, 
	COUNT(CASE WHEN NOT upvote THEN 1 ELSE NULL END) as downvote_count 
	FROM votes v
	WHERE v.thread_id IN (SELECT id FROM selected_threads)
	GROUP BY v.thread_id
)
SELECT 
    -- thread info
	st.id, st.root_id, st.parent_id, st.author_id, st.created_at, st.title, st.content,
    -- extended info
	u.username,
	coalesce(rc.reply_count, 0) as reply_count,
	coalesce(vc.upvote_count, 0) as upvote_count,
	coalesce(vc.downvote_count, 0) as downvote_count,
	EXISTS (SELECT 1 FROM votes v1 WHERE v1.thread_id = st.id AND v1.voter_id = $1 AND v1.upvote = TRUE) as has_upvoted,
    EXISTS (SELECT 1 FROM votes v2 WHERE v2.thread_id = st.id AND v2.voter_id = $1 AND v2.upvote = FALSE) as has_downvoted
FROM selected_threads st
LEFT JOIN reply_counts rc ON st.id = rc.thread_id
LEFT JOIN vote_counts vc ON st.id = vc.thread_id
INNER JOIN users u ON st.author_id = u.id
`

type GetThreadsParams struct {
	ReaderID         sql.NullInt32
	AuthorID         sql.NullInt32
	RootID           uuid.NullUUID
	RootThreadsOnly  bool
	ChildThreadsOnly bool
}

type GetThreadsRow struct {
	ID            uuid.UUID
	RootID        uuid.UUID
	ParentID      uuid.NullUUID
	AuthorID      int32
	CreatedAt     time.Time
	Title         sql.NullString
	Content       string
	Username      string
	ReplyCount    int64
	UpvoteCount   int64
	DownvoteCount int64
	HasUpvoted    bool
	HasDownvoted  bool
}

func (q *Queries) GetThreads(ctx context.Context, arg GetThreadsParams) ([]GetThreadsRow, error) {
	rows, err := q.db.QueryContext(ctx, getThreads,
		arg.ReaderID,
		arg.AuthorID,
		arg.RootID,
		arg.RootThreadsOnly,
		arg.ChildThreadsOnly,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetThreadsRow
	for rows.Next() {
		var i GetThreadsRow
		if err := rows.Scan(
			&i.ID,
			&i.RootID,
			&i.ParentID,
			&i.AuthorID,
			&i.CreatedAt,
			&i.Title,
			&i.Content,
			&i.Username,
			&i.ReplyCount,
			&i.UpvoteCount,
			&i.DownvoteCount,
			&i.HasUpvoted,
			&i.HasDownvoted,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUser = `-- name: GetUser :one
SELECT id, username, password, created_at FROM users WHERE username=$1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUser, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Username,
		&i.Password,
		&i.CreatedAt,
	)
	return i, err
}

const users = `-- name: Users :many
SELECT id, username, password, created_at FROM users
`

func (q *Queries) Users(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, users)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.Password,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
